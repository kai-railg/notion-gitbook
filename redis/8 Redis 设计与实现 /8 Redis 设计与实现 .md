# 8 Redis 设计与实现

- 1 数据结构与对象
    - SDS  简单动态字符串
        - 概述

            Redis 自己构建了名为 <简单动态字符串 simple dynamic string，SDS> 的抽象类型，并将 SDS 作为 Redis 的默认字符串表示。

            字符串键值对在数据库底层的实现就是由 SDS 实现的。

            Redis 的键值对的类型规范：

            - 键必须是字符串
            - 值可以是五种数据类型中的任意一种

            除了用来保存数据库的字符串值之外，SDS 还作为缓冲区

            - AOF 缓冲
            - 客户端的输入缓冲
        - 定义
            - 结构体类型
            - 三个属性
                - int len    记录buf数组已使用字节的长度
                - int free   未使用字节的数量
                - char buf[]   字节数组，保存字符串
        - 与 C 字符串的区别
            - C 字符串获取长度需要遍历，复杂度为 O(N)；SDS 为 O(1)
            - C 字符串操作时不主动进行内存重分配，可能造成缓冲区溢出或内存泄漏；SDS 首先检查缓冲区空间是否足够用
            - SDS 优化内存重分配策略
            - C 字符串中不能出现空格字符；SDS 以二进制的方式来处理字符串，所以 buf 被叫做字节数组，因此 SDS 得 len 字段来判断字符串结束的位置
        - SDS 优化内存重分配策略
            1. 空间预分配
                - 如果SDS 的长度小于 1MB，分配len属性同样大小的未使用空间；下次分配时，先判断未使用空间是否足够使用
                - 如果大于 1MB，则未使用空间分配1MB
            2. 惰性空间释放
                - 进行字符串缩短操作时，并不直接回收缩短多出来的字节，而是当作未使用空间，通过 free 字段记录下来
        - SDS 的优点
            - 获取字符串长度为常数复杂度
            - 杜绝缓冲区溢出
            - 内存重分配优化策略
            - 二进制安全
            - 兼容部分 C 字符函数
    - 链表
        - 功能应用
            - 列表键(双端链表)
            - 发布与订阅
            - 满查询
            - 监听器
            - 其他
        - listNode 结构体实现
            - 前驱
            - 后继
            - 节点的值
        - list 结构体实现
            - 表头节点
            - 表尾节点
            - 链表包含的节点数量
            - 节点值复制函数
            - 节点值释放函数
            - 节点值对比函数（判断和另一个输入的值是否相等）

        list 的头节点关联和尾节点分别关联一个 listNode， listNode 之间互相关联，就实现了一个双端链表

        - Redis 链表的特性
            - 双端
            - 无环(listNode 链表的头节点和尾节点分别指向NULL，由list 中的头节点和尾节点来对应关联)
            - 带头节点和尾节点，由 list 实现
            - 带链表长度计数， 由 list 实现
            - 多态， 各节点的三个函数可以设置特定类型的值， 由 listNode 实现

    - 字典
        - 概述

            又称符号表、关联数组、映射。

            Redis 构建了自己的字典实现，是哈希键的底层实现之一

            使用哈希表作为字典的底层实现

            字典的使用场景：

            - 键值对中的元素还是比较长的字符串时
            - 哈希键包含的键值比较多
        - 哈希表
            - 结构
                - 哈希表数组（保存一对键值） table
                - 哈希表大小  size
                - 哈希表大小掩码，用于计算索引值（总是等于 size - 1）
                - 已有节点的数量  used（键值对的数量）
            - 图示

                ![8%20Redis%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%2054156f1b25c444c1a7d9e557c3b134f0/Untitled.png](8%20Redis%20%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%2054156f1b25c444c1a7d9e557c3b134f0/Untitled.png)

        - 哈希表节点
            - 结构
                - 键
                - 值（类型：指针、uint64_t、int64_t）
                - 指向下个节点的指针（多个键相同节点使用一个指针）
        - Redis 字典的实现
            - 结构体
                - 类型特征函数
                - 私有数据
                - 哈希表
                - rehash(重新) 索引，不在rehash 时为-1
                - 计算哈希值的函数
                - 复制键的函数
                - 复制值的函数
                - 对比键的函数
                - 销毁键的函数
                - 销毁值的函数
        - 解决键值冲突

            当两个或以上的键被分配到哈希表数组的同一个索引上，成为键值冲突

            Redis 使用链地址法解决键值冲突。

            多个哈希表节点使用 next 后继指针 以索引为头节点，构成一个单向链表

        - rehash

            当哈希表保存的键值对数量太多或太少，需要对哈希表的大小进行再分配，主要是为了让哈希表的负载因子 维持在一个合理的范围内。

            再分配的工作可以让 rehash 来做，其步骤为：

            - 为字典中的空白哈希表分配空间
            - 将要重新分配的哈希表上所有数据渐进式的 rehash 到空白哈希表中
                - rehash 指的是重新计算键的哈希值和索引值，保存到对应的位置中
            - 迁移完成后，释放原来的哈希表
            - rehash 的条件
                1. 服务器目前没有执行 BGSAVE 和 BGREWRITEAOF 命令，且负载因子大于1
                2. 正在执行上述两条命令，且负载因子大于5
            - 渐进式

                rehash 动作不是一次性、集中的完成的，而是分多次、渐进式的完成的

                通过rehash 索引来记录当前工作的进度

                在 rehash 过程中，Redis 对字典的操作会访问两个哈希表

    - 跳跃表

        应用：

        - 有序集合
        - 集群节点