# MySQL的Join

- 关于MySQL Join 的问题，一般集中在两类
    - 到底能不能用Join
    - Join时用的哪个表做驱动表
- **Index Nested-Loop Join**
    - 针对被驱动表可以用上索引的情况
    - `select * from t1 straight_join t2 on (t1.a=t2.a);`
        - t2 的a有索引
        - 如果直接使用 Join，MySQL优化器可能会选择t1或t2做驱动表，影响我们分析SQL的执行过程，所以直接使用 `straight_join` 明确驱动表是t2
    - 这个语句的执行过程如下
        - 从表t1读出一行数据R
        - 从数据行R中，取出a字段到t2表里查找
        - 取出t2中满足条件的行，跟R组成一行，作为结果集的一部分
        - 重复执行该步骤，直至t1扫描完毕
    - 这个过程是先遍历t1，然后从t1中取出每行数据到t2表查询。这个过程跟我们写程序的嵌套类似，并且可以用上被驱动表的索引，我们称之为 **Index Nested-Loop Join，简称 `NLJ`。**
    - 在这个流程里，
        - 对驱动表t1做了全表扫描，假设100行
        - 对于每一行R，到t2表通过索引查找，假设数据是一一对应的，因此每次扫描只扫描一行，总共也是100行
        - 合计200行
    - 如果不使用Join，流程如下
        - 对t1全表扫描，取出所有数据，这里有100行
        - 循环遍历这100行数据，依次和t2表的a对比
            - 执行 select * from t2 where a=R.a；
                - 需要执行100行
        - 合计201行
    - 不适用Join额外对了一行SQL，并且还多了100次交互，还要自己处理遍历和合并的逻辑，`显然，不如使用Join`
    - 在这个Join里，驱动表走的全表扫描，驱动表和被驱动表大小是一致的
        - 假设 N 为驱动表行数，M为被驱动表行数，时间复杂度为  $N + N*2*log2M$
        - 因此得出结论，`应该让小表做驱动表`  前提是可以使用被`驱动表的索引`

- **Simple  Nested-Loop Join**
    - 针对被驱动表没有可用索引的情况
    - 时间复杂度 N * M ，加上IO查询，太笨重了，MySQL也没有使用这种方法
    - 而是使用了 Block Nested-Loop Join
- **Block Nested-Loop Join**
    - 简称 `BNL`
    - 针对被驱动表没有可用索引的情况
    - 时间复杂度 N * M，不过是分别把 t1 和 t2 读到内存中，依次进行判断
    - 如果表太大内存无法一次性放入，则会分段放，类似归并排序
- 所以，针对Join能不能用的问题
    - 如果被驱动表上有可用的索引，会使用NLJ，那是可以用的
    - 如果被驱动表上无可用的索引，会使用BNL，那不推荐使用Join
- 针对Join用哪个表做驱动的问题
    - `应该总是小表做驱动`
    - 更准确地说，在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。
- 同时，MySQL还对Join做了一些优化
- **Multi-Range Read**
    - `MRR`，优化的主要目的是尽量使用顺序读盘
    - 因为大多数的数据都是按照主键递增顺序存的，所以我们认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升性能
    - MRR提升性能的核心在于，这条查询语句在索引a上做的是一个范围查询，可以得到足够多的主键，通过排序以后，就可以体现出`顺序性`
- **Batched Key Access**
    - `BKA`  算是对NLJ的优化
    - BKA的会局部依赖MRR
-