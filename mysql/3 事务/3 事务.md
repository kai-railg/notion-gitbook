# 事务

- 事务的ACID特性及其实现
    - Atomicity 原子性（undo log）
    - Consistency 一致性（MVCC）
    - Isolation  隔离性（隔离级别）
    - Durability 持久性（redo log + binlog）
- 当数据库上有多个事务同时执行时，就可以出现`脏读`、`不可重读`、`幻读`等问题，为了解决这些问题，就有了隔离级别的概念。
- 隔离级别和效率是成反比的关系，隔离级别越高，效率就越低。
- SQL标准的事务隔离级别包括
    - `读未提交` read uncommitted
        - 一个事务还没提交时，它做的变更就可以被其他事务看到
    - `读提交` read committed
        - 一个事务提交之后，它做的变更才可以被其他事物看到
    - `可重读` repeatable read
        - 一个事务看到的数据，总是跟这个事务在启动时看到的数据是一样的
    - `串行化` serializable
        - 当出现读写冲突时，比如等前一个事务执行完才能继续执行
- 隔离级别的理解

    ![%E4%BA%8B%E5%8A%A1%202ad548d77a0f41b9b550d0b1d4586cc1/Untitled.png](%E4%BA%8B%E5%8A%A1%202ad548d77a0f41b9b550d0b1d4586cc1/Untitled.png)

    - 在读未提交下，v1、v2、v3是2，因为事务B在未提交下也可以被事务A读到
    - 在读提交下，v1是1，读不到未提交的事务，v2、v3是2
    - 在可重读下，v1、v2是1，事务读到的数据和它启动时的一样，v3是2
    - 在串行化下，v1、v2是1，事务B会等待事务A提交才会执行更新，v3是2
- 在事务隔离级别的实现上，数据库里面会创建一个视图，访问的时候以`视图的结果`为主。
    - 在可重读隔离级别下，这个视图是在`事务启动时创建`的，整个事务期间都使用这张视图。
    - 在读提交隔离级别下，这个视图是在每个SQL开始执行时创建的。
    - 在读未提交隔离级别下，不存在视图，每次读使用行记录的最新值
    - 而串行化是使用加锁的方式避免并行访问
- MySQL的默认隔离级别是`可重读`，而Oracle的默认隔离级别是读提交

    ![%E4%BA%8B%E5%8A%A1%202ad548d77a0f41b9b550d0b1d4586cc1/Untitled%201.png](%E4%BA%8B%E5%8A%A1%202ad548d77a0f41b9b550d0b1d4586cc1/Untitled%201.png)

- 事务隔离的实现
    - 隔离级别为可重读
    - MySQL中每条记录更新时都会记录一条`回滚操作`（undo log会记录事务开始前的状态）。记录上最新值，都可以通过`回滚`，得到一个`以前的值`。
    - 假设一个值从1被改成2、3、4，那么最新值就是4，可以通过4回滚到3、2、1。在`不同时刻`启动的事务里，`视图里的值`可能是不一样的。
    - 同一条记录在系统中可以存在`多个版本`，通过版本号来控制事务中视图的值，就是数据库里的`MVCC`(多并发版本控制)。
- 事务的启动方式
    - 显示的启动 begin 或 start transaction
        - 提交  commit
        - 回滚 rollback
        - commit work and chain  提交事务并启动下一个事务
        - `set autocommit=1` 通过显示的语句启动事务
        - 查询60s以上的事务

            ```jsx
            select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60;
            ```