# MySQL高可用

- 在一个主备关系中，每个备库接收主库的binlog并执行
- 正常情况下，备库只要主库执行更新生成的所有binlog，都可以传到备库被正常的执行，备库就能达到跟主库一致的状态，这就是`最终一致性`。
- 但是，`MySQL要提供高可用能力`，只有最终一致性是不够的
- 以M-M架构为例详细说明
- **主备延迟**
    - 同步延迟，与数据同步有关的时间点包括三个
        - 主库A执行一个事务，写入binlog，记为T1
        - 传给备库并备库接收完，记为T2
        - 备库执行完这个事务，记为T3
    - 所谓主备延迟，就是一个事务，在备库完成的时间与主库完成的时间差，即`T3-T1`
        - 在备库上执行 `show slave status`， `seconds_behind_master` 表示备库延迟了多少秒

    主备延迟最直接的表现是，`备库消费中转日志 relay log 的效率，比主库生产binlog 的速度要慢`

- **主备延迟的来源**
    - 备库的机器性能比主库差
    - 备库的压力大
        - 比如跑一些运营类的查询语句
        - 针对压力大的处理方法
            - 一主多从
            - 通过binlog输出到外部系统，比如Hadoop系统，让外部提供统计查询的能力
    - 大事务
        - 如果主库的事务执行了10分钟，那么事务就可能导致从库延迟10分钟
            - 常见的场景是一次性删除过多数据
        - 大表DDL
            - 可以有计划的采用gh-host
    - 备库的并行复制能力
        - binlog在备库的同步，MySQL5.6之前只支持单线程复制，因此在主库并发高、TPS高的情况下，就会出现严重的主备延迟情况
        - MySQL从单线程复制到多线程复制，中间经历过几个版本
        - 归根结底，多线程复制机制，就是把一个的sql_thread拆成多个线程
            - 原先的sql_thread改为`coordinator` ，只负责读取中转日志和分发事务
            - 引入了worker线程，专门负责更新日志
                - `slave_parallel_workers` 决定线程的个数，一般占物理机的1/4-1/2
            - worker是不能按照轮询的方式处理，由于CPU 的调度策略可能会导致线程执行时间错误
            - 也不能拆分事务的多条语句，因为如果有查询在更新的期间执行，可能会破坏事务逻辑的隔离性
            - 所以，`coordinator` 在分发事务的时候，需要遵循以下要求
                - 不能造成覆盖更新，要求同一个事务必须被分发到同一个worker上
                - 同一个事务被拆开
        - 按表分发策略
            - 如果事务更新的不同的表，那么他们可以并行
        - 按行分发策略
        - 按库分发策略
    - 其他
        - 主库和从库的配置不一样
        - 备库表上无索引的情况
        - 设置的延迟备库
        - 备库存储空间不足
- 由于主备延迟的存在，在进行主备切换的时候，就有不同的切换策略
- **可靠性优先策略**
    - 双M架构下详细流程
        1. 判断备库的`seconds_behind_master` 如果小于某个值继续下一步，否则重试
        2. 把主库改为readonly状态
        3. 判断备库的`seconds_behind_master` 直至等于0
        4. 把备库改为可读写状态，readonly=false
        5. 把业务请求切换到备库
    - 这个切换流程，一般是由专门的HA系统
    - 这个流程是`有数据库不可用时间的`，这也是为什么判断 `seconds_behind_master` 的原因
- **可用性优先策略**
    - 如果把步骤4、5调整到最开始执行，即不用等主备数据同步，直接让备库执行读写，那么系统就没有不可用时间了
    - 这个流程切换的代价，就是可能会出现数据不一致的情况
- MySQL的高可用，是依赖主备延迟的，主备延迟越小，可用性就越高