# 读写分离下的主备延迟问题

- 本文主要介绍读写分离，以及怎么处理主备延迟导致的读写分离问题
- 一主多从的架构，就是读写分离的基本结构。
    - 可以由客户端主动做负载均衡
        - 直连的方式查询性能会稍微好点，整体架构简单，缺点是需要在后端部署细节，客户端会感知到细节
    - 也可以由中间层proxy做路由分发
        - 架构相对复杂，而且有高可用架构。对技术实现要求较高，对客户端比较友好
    - 目前，趋势在往proxy方向发展
- 读写分离的主要目标是分担主库的压力
- 问题
    - 由于主从可能存在延迟，因此客户端刚执行完一个事务后马上发起一个查询，如果查询选择的是从库的话，那么有可能读到的就不是最新的数据
- 这种在从库上读到一个系统的过期状态，我们称之为过期读
- 主从延迟是不可避免的，我们给出了几种处理过期读的方案
    1. 强制走主库方案
    2. sleep方案
    3. 判断主备无延迟方案
    4. 配合 semi-sync 方案
    5. 等主库位点方案
    6. 等GTID 方案
- **强制走主库方案**
    - 将查询请求做分类，可以分为两类
        - 对于必须拿到最新结果的数据，强制将其发到主库上
        - 对于接受旧数据的请求，才将其发到从库上
    - 如果碰到所有的请求都不能是过期读，那就不能使用该方案
- **slepp 方案**
    - 主库更新后，读从库时，先执行一条 select sleep(1);
    - 这个方案的假设是，大多数数据，在从库 sleep 1秒后，可以拿到最新的数据
    - 有种类似的方案
        - 用户发布商品后，前端直接把发布的商品信息返回，作为新的商品展示，而不是真正去数据库做查询
        - 等到卖家刷新的时候，已经过了一段时间了，自然就拿到最新的数据了
- **判断主备无延迟方案**
    - 每次查询请求前，先判断`seconds_behind_master` 是否等于0
    - 对比位点确保主备无延迟
        - Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点；
        - Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。
    - 对比GTID确保主备无延迟
        - Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。
        - Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集
        - Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。
- **配合 semi-sync**
    - 引入半同步复制，也就是 semi-sync replication
    - semi-sync 做了如下设计
        - 事务提交的时候，主库把binlog发给`任意一个`从库
        - 从库收到binlog之后，发给主库一个ack
        - 主库收到ack之后，才会给客户端返回事务完成的确认
    - **`semi-sync + 判断主备无延迟`**的方式，就可以避免过期读，但是只是在一主一从 的场景下才可以确保，如果请求落在没有收到binlog的机器上，就会产生过期读的问题
    - 还有一个潜在的问题，如果在业务高峰期，位点或者GTID更新的很快，那么两个位点的等值判断就会一直不成立
    - 当收到一个查询请求后，并不一定要等到`主备完全同步`
        - 因为事务延迟 的话，semi-sync 可能会导致查询过度等待
    - semi-sync 的两个问题
        - 一主多从下可能会产生过期读的问题
        - 如果事务延迟，可能会导致过度等待
    - 等主库位点的方案，可以解决这两个问题
- **等主库位点方案**
    - `select master_pos_wait(file, pos[, timeout]);`
    - 这条命令的逻辑如下
        - 是在从库执行的
        - 参数 file 和pos指的是主库的binlog文件和位置
        - timeout是可选的，表示最多等待多少时间
        - 返回结果正常是一个正整数，表示从命令开始执行，到应用完file和pos，一共执行了多少事务
    - 所以，执行查询的逻辑如下
        - 主库事务更新完，马上执行 show master status; 得到当前主库的file和pos
        - 从库执行`select master_pos_wait(file, pos[, timeout]);` 语句
        - 如果返回值是 ≥0 的值，则在从库上执行查询语句
        - 否则到主库上执行查询语句
    - 比如我们设定select查询在从库上最多等待1秒，如果1秒内`master_pos_wait` 返回一个正整数，表示主库的事务已经同步。
- **等GTID 方案**
    - 如果MySQL开始了GTID，也可以用等GTID方案，和等主库位点方案类似
    - `select wait_for_executed_gtid_set(gtid_set, 1);`
    - 执行该命令，