# 锁

- MySQL里的锁根据级别大致可以分为`全局锁`、`表锁`、`行锁`三类。根据策略可以分为`读锁`、`写锁`两类。
- 全局锁
    - 对整个数据库加锁。
    - MySQL提供了一个加全局读锁的方法， `flush tables with read lock`
        - `--single-transaction` 执行前先启动一个事务，需要引擎支持，同MVCC
    - 全局锁典型的使用场景是`全库逻辑备份`，Server层使用
        - 全库逻辑备份也可以在可重读的隔离级别下开启一个事务做，由于MVCC，是支持数据更新的。引擎层使用。
    - 不建议使用 `set global readonly=true`
        - readonly 参数会被用作其他逻辑，比如主备判断逻辑
        - 异常处理上 readonly 不会释放锁
        - readonly 对 super 权限无效
- 表锁
    - 表锁可以分为`表锁`和`元数据锁`
    - 表锁
        - `lock tables t1 read/write`
        - `unlock tables`
            - 释放锁，也可以在断开连接的时候释放
        - 表锁除了会限制其他线程的读写外，也会限制本线程对其他的表的读写。
    - 元数据锁 (`metadata lock`)   MDL
        - MDL 不需要显示的使用，在访问一个表时会被自动的加上。
        - MDL的作用，保证`读写的正确性`。
        - 当对一个表做增删改查操作的时候，加MDL读锁；对表结构变更的时候，加MDL写锁
            - 读锁之间不互斥
            - 读写锁、写锁之间是互斥的
        - 对小表加一个字段，导致一个库挂了？
            - `alter table 请求会申请写锁`，如果有之前有读锁需要`等读锁释放`，进入`阻塞状态`。之后的请求如果`再次申请MDL读锁`，就会被锁住。如果在DML写锁后有大量查询请求，并且客户端有重试机制，这个库的线程很快会超负荷。
            - 合理的做法是
                - 如果有长事务，先kill掉长事务
                - 设置 alter table 的时间，如果指定时间内拿不到写锁，拿不到就放弃，之后再进行重试
- 行锁
    - MySQL的行锁是由引擎自己实现的。
    - **两阶段锁**
        - InnoDB中，行锁是在`需要的时候`才加上，但并不是不需要了就释放，而是等到`事务提交才释放`。这就是两阶段锁协议。
    - 如果降低行锁的影响
        - 把最有可能造成锁冲突的、最可能影响并发度的锁尽量往后放
    - 死锁和死锁检测
        - 当并发系统中不同线程出现`循环资源依赖`，涉及的线程都在`等待别的线程`释放资时，就会导致这几个线程都进入无限等待的状态。称为死锁。

            ![Untitled%20454de6825cf5425daeb7f5b6897bde12/4d0eeec7b136371b79248a0aed005a52.jpg](Untitled%20454de6825cf5425daeb7f5b6897bde12/4d0eeec7b136371b79248a0aed005a52.jpg)

        - 事务A在等待事务B释放ID=2的行锁，事务B在等待事务A释放ID=1的行锁，就造成了死锁。
        - 解决死锁的策略
            - 直接进入等待，设置超时时间，超过时间线程退出
                - `innodb_lock_wait_timeout` 设置，默认50s
                - 设置的太小会造成误伤，可能会杀死锁等待的线程
            - 发起死锁检测，主动回滚死锁中的某一个事务，让其他事务得以进行
                - `innodb_deadlock_detect`=on 表示开启这个逻辑，默认on
                - 但是有`额外负担`，极端的情况如果是所有事务都要更新同一行事务，会造成性能的问题，占用很高的CPU。
                - 控制并发度，降低死锁检测的时间成本。在数据库服务端做，可以使用中间件。基本思路是在进入引擎前排队。
                - 还有一种方法是`拆行`，单行的值拆成多行进行累加。

- 间隙锁