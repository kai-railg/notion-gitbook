# 幻读+间隙锁

- 幻读的现象
    - 在可重读隔离界别下，一个事务在前后两次同一个范围时，后一次查询看到前一次查询没有的行
- 幻读的分析和问题
    - 在可重读隔离界别下，事务前后看到数据是一致的
    - 但是是`当前读`的情况，事务中更新了一条数据后再次查询，就会返回当前最新的数据，而最新的数据中出现了第一次查询没有的行，这就是幻读
    - 幻读仅指`新插入的行`
    - 我们之前讲到的锁，都是对已有数据加的锁，但是这阻止不了新插入的记录。因为在加锁的时候，这条记录还不存在，自然是加不了锁。
    - 因此，幻读会破坏数据一致性的问题。
        - 示例

        ![%E5%B9%BB%E8%AF%BB+%E9%97%B4%E9%9A%99%E9%94%81%201f1cba0f1f914882a099607895cd72ab/Untitled.png](%E5%B9%BB%E8%AF%BB+%E9%97%B4%E9%9A%99%E9%94%81%201f1cba0f1f914882a099607895cd72ab/Untitled.png)

- 幻读的解决
    - 幻读产生的原因，是行锁只能锁住行，针对不了新插入行的操作。
    - 因为，为了解决幻读的问题，InnoDB引入了新的锁，`间隙锁`。
        - 锁的是两个值的空隙，新产生的记录更新的就是记录之间的间隙
        - 比如d=5的主键ID们

            ![%E5%B9%BB%E8%AF%BB+%E9%97%B4%E9%9A%99%E9%94%81%201f1cba0f1f914882a099607895cd72ab/Untitled%201.png](%E5%B9%BB%E8%AF%BB+%E9%97%B4%E9%9A%99%E9%94%81%201f1cba0f1f914882a099607895cd72ab/Untitled%201.png)

            - 再执行`select * from t where d=5 for update`，就不仅仅是加6个行锁，还加了行记录间的7个间隙锁
- 间隙锁之间不存在冲突，跟间隙锁冲突的是，在间隙间新增一个记录
    - 间隙锁和行锁合称 `next-key lock` ，是`前开后闭区间`。
- 间隙锁带来的问题
    - insert 语句可能会导致死锁，行记录使用上图的示例

        ![%E5%B9%BB%E8%AF%BB+%E9%97%B4%E9%9A%99%E9%94%81%201f1cba0f1f914882a099607895cd72ab/Untitled%202.png](%E5%B9%BB%E8%AF%BB+%E9%97%B4%E9%9A%99%E9%94%81%201f1cba0f1f914882a099607895cd72ab/Untitled%202.png)

    - session A 和 session B执行 select 都会形成 (5, 10) 间隙锁，读不影响所以不冲突
    - session B 执行 insert 语句，和 session A的间隙锁 (5, 10) 冲突，等待 session A 释放间隙锁
    - session A 执行 insert 语句，和 session B的间隙锁 (5, 10) 冲突，等待 session B 释放间隙锁
    - 形成死锁