# 事务的隔离实现和当前读

- 问题
    - 在可重读(RR)的隔离级别下，一个事务启动时会创建一个视图read-view，在事务执行期间，它看到的值前后一致且不受其他事务影响。
    - 假设一种情况是，事务执行中遇到update语句，且另外一个事务持有该行的行锁，那么等到这个update语句获取行锁开始执行时，它读到的值又是什么，它更改后事务里读到的值又和事务启动时看到的是一样吗？
- 案例
    - 三个事务A、B、C

        ![%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB%20e9bc926402294679932072ae539e9d59/Untitled.png](%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB%20e9bc926402294679932072ae539e9d59/Untitled.png)

    - `start transaction with consistent snapshot` 表示马上启动一个事务，而不是等到语句执行
    - 默认autocommit=1，事务C执行完update就会自动提交
    - 这时候事务A和事务B看到的值分别是多少呢
        - 事务A是1，符合RR隔离级别的`一致性读`
        - 事务B是3，引入`当前读`的概念，update更新前会获取`最新的值`，并覆盖视图中原先的值
    - 我们需要进一步的理解MVCC
- read-view视图
    - 在RR隔离级别下，事务在启动时会创建一个视图`read-view`，即`快照`。这个快照是基于整个数据库的。但是并不需要完整的拷贝整个数据库。
    - read-view的实现
        - InnoDB中每个事务都有一个唯一的`递增`的事务ID，叫做 `transaction id`。
        - 而每行数据也是有多版本的，每次数据更新时，都会生成一个`新的版本`，该版本会保留一个当前的事务ID，记做`row trx_id`。
        - 就是说，数据包的一行数据，可能有多个版本，每个版本有一个`row trx_id`。

            ![%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB%20e9bc926402294679932072ae539e9d59/Untitled%201.png](%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E5%AE%9E%E7%8E%B0%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB%20e9bc926402294679932072ae539e9d59/Untitled%201.png)

        - 该图表示一行有4个记录，从v1更新至v4，但是v1-v3并不是真实存在，而是v4(当前版本)通过`undo log`计算出来的。
        - 假如一个事务是在v3时刻启动的，那么对于v4它就不应该是看见的，所以
            - **一个事务的视图以启动时刻的数据版本为准，可以看到之前的，而看不到之后的**
            - **如果是这个事务自己更新的版本，那也是可见的(`当前读`)**
        - 实现上，InnoDB为每个事务构造一个数组，用来保存事务启动时`活跃`的事务，活跃是指启动了但是还没提交。
        - 事务数组中的事务ID最小值记为`低水位`，当前系统中事务ID的最大值记为`高水位`
        - 而这个事务数组和高、低水位就构成了`read-view`。
- 那么一致性读和最新的值又是怎么实现的呢？
    - 数据版本的可见性规则，就是基于read-view和数据版本的`row trx_id`对比结果。
    - 这个事务数组把`row trx_id` 分成几种情况
        - `row trx_id` 小于低水位，表示版本是已提交的事务，可见
        - `row trx_id` 大于高水位，表示事务是由将来的事务生成的，不可见
        - `row trx_id` 大于低水位并且小于高水位
            - `row trx_id` 在数组中，表示这个版本是由活跃的事务生成，不可见
            - `row trx_id` 不在数组中，表示版本是已提交的，可见
        - 通过高水位的值回滚计算可以得到低水位的值，事务的值和水位进行对比，就可以确定这个事务应该看到的值。
        - 简言之
            - 数据版本未提交，不可见
            - 数据版本已提交，但是在视图创建后提交的，不可见
            - 数据版本已提交，是在视图创建之前提交的，可见
            - 数据版本对自己的更新总是可见
        - 更新的逻辑
            - 更新数据都是`先读后写`的，而这个读，只能读当前的值，称为当前读。
        - 如果select加锁也是当前读
            - select  * from t for update;
            - select * from t lock in share mode;
        -