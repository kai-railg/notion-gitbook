# order by 的工作原理

- 全字段排序
    - 为了避免全表扫描，我们需要对排序的字段加上索引
    - MySQL会给每个线程分配一块内存用于排序，成为 `sort_buffer`.
    - 排序的流程
        - 初始化 `sort_buffer` 放入需要排序的字段
        - 从索引中找到满足满足查询条件的主键ID
        - 回表取出需要排序的字段数据
            - 如果有覆盖查询则不需要
        - 对`sort_buffer` 的数据做快排
        - 返回排序结果
    - 如果排序需要借助外部存储空间，则利用磁盘临时文件辅助排序
- row_id 排序
    - 如果全字段排序时返回的字段很多时，会导致占用空间太大，排序性能下降，所以单行很大，全字段排序的方式效率不够好。
    - `show variables like "max_length_for_sort_data";`
        - 单行时排序的最大长度，默认1024；如果单行超过这个长度，就换一个算法。
    - 新的算法放入 `sort_buffer` 的字段，只有要排序的字段和主键ID
    - 所以，相比较全字段排序，row_id排序的方式
        - 排序过程中不需要额外的参与，减少了排序时的空间占用
        - 返回结果时需要根据排序后的主键ID`回表`获取完整数据
    - row_id 排序虽然减少了磁盘的占用，但是增加了回表IO操作，因此不会被`优先选择`
- 通过`联合索引`的方式，可以使查询到的数据`直接是有序的`
    - 如果使用limit，可以直接查询前 limit 定义的数据
- 通过`覆盖索引`的方式，可以直接返回有序的数据，而不需要回表查询。
-