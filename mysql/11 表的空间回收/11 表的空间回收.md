# 表的空间回收

- InnoDB的表包含两部分
    - 包结构定义，占用空间很少
    - 表数据，主要讨论的对象
        - show variables like "innodb_file_per_table";
            - 表示表数据不使用共享表空间，而是存放在单独的文件中。默认为ON
    - 遇到的问题
        - 表中的数据被删除了，表空间却没有被回收
    - 数据删除流程
        - 如果删除一条记录，InnoDB会把这个`标记为删除`，后面插入合适的数据会复用这个位置，因此磁盘空间不会缩小
            - 比如删除了ID=4的记录，又插入了ID=4的记录
        - 如果是删除一个数据页，我们知道InnoDB的数据是按页存储的，那么结果就是这一页可以被复用了
        - 不过，`数据页的复用跟记录的复用是不同的`
        - 记录的复用，只限于符合范围条件的数据。而数据页的复用，可以复用到任何位置。
        - 如果相邻的两个页的利用率都很低，那么InnoDB会把这两个页合并到一个页上，空出的数据页就被标出可复用。
        - 因此，在删除表数据的时候，空出的数据页就被标记可复用，`磁盘上不会减小`
        - 所以，`删除命令不会造成表空间的回收`，而是造成空间的可复用，而未被使用的空间，就像是空洞。
        - 另外，插入数据也可能会造成空洞，比如页分裂。
        - 如果能把这些空洞去掉，就能达到表空间回收的目的
    - 重建表回收表空间
        - 把表中的数据插入到另一个表结构一样的表中，完成后进行替换，就是表重建。
        - 新建的表就不存在索引上的空洞，主键更加紧凑，就起到了收缩表空间的作用
        - `alter table A engine=InnoDB;`  重建表的命令
            - MySQL会自动的完成数据存储、交换表名、删除旧表等操作
        - 重建表之后，InnoDB不会把每个数据页占满，而是`预留了每个页的1/6`做后续的更新用。
    - Online DDL
        - 在重建表的步骤中，如果有新的数据要写入到表A的话，就会造成数据丢失。因此在这个DDL中，表A中不能有更新。也就是说，这个DDL不是online DDL的。
        - MySQL5.6引入了Online DDL，重建表的流程为
            1. 建立一个临时文件，扫描表A中所有数据
            2. 生成B+树，存储到临时文件中（最耗时的一步）
            3. 生成临时文件过程中，将对表A的操作记录到日志中
            4. 临时文件生成后，将日志中的操作应用到临时文件中
            5. 用临时文件替换表A的数据文件
    - Online 和 inplace