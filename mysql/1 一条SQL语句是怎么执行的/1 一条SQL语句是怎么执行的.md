# 一条SQL语句是怎么执行的

- 执行过程概述和架构图
    - 架构图

        ![%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%20211e2dbb68cf4e7b99d61dfe95d8a6d1/Untitled.png](%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%20211e2dbb68cf4e7b99d61dfe95d8a6d1/Untitled.png)

    - MySQL可以分为`Server层`和`存储引擎层`。
        - Server层包括连接器、分析器、优化器、执行器等，涵盖大部分的核心功能，以及`内置函数`，所有`跨引擎存储`（存储过程、触发器、视图等）
        - 存储引擎层是插件式的，负责数据的`存储和提取`。包括InnoDB、MyISAM、Memory等。5.5开始默认使用InnoDB存储引擎。
    - 连接器
        - 负责跟客户端`建立连接`、`获取权限`、`维持和管理连接`。
            - 典型的命令就是 `mysql -u name -p password`
        - 流程上是
            - 发起建立连接请求 → TCP三次握手 → 验证账号和密码 → 验证权限
                - 一旦连接建立后，在本次连接中权限就不受其他连接修改的影响，比如管理员修改了该账号的权限
        - 连接建立后，可以通过 `show processlist;` 查看

            ![%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%20211e2dbb68cf4e7b99d61dfe95d8a6d1/Untitled%201.png](%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%20211e2dbb68cf4e7b99d61dfe95d8a6d1/Untitled%201.png)

            - Command为Sleep的连接表示这个是一个空闲连接
            - 空闲到一定时间，系统会自动断开连接。时间由参数`wait_timeout` 设定，默认8小时

                ![%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%20211e2dbb68cf4e7b99d61dfe95d8a6d1/Untitled%202.png](%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%20211e2dbb68cf4e7b99d61dfe95d8a6d1/Untitled%202.png)

        - 长连接和短连接
            - 长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。
            - 短连接是指连接成功后，执行完查询后就断开连接，下次查询重新建立一个
            - 长连接的优劣
                - 可以减少建立连接的动作，但是会导致`内存升的特别快`。
                - 这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里的，只有连接断开的时候才会释放。可能导致OOM，即MySQL异常重启了。
            - 如何解决`长连接内存占用`的问题？
                - 定期断开长连接，或者做内存占用的判断及时断开
                - 每次执行完一个大操作后执行`mysql_reset_connection`命令，重新初始化连接资源，不需要重连和安全校验，而是恢复成`连接刚创建的状态`

    - 查询缓存
        - 连接建立后，就可以执行select语句了。
        - 执行逻辑首先会`查询缓存`，存在就直接返回，不存在执行完成缓存执行结果
        - 查询缓存的失效非常频繁，任何关于表的`更新`都会让这个表的`缓存失效`
        - 可以通过 query_cache_type 变量设置
            - 必须在启动前设置 query_cache_type 变量

            ![%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%20211e2dbb68cf4e7b99d61dfe95d8a6d1/Untitled%203.png](%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%89%A7%E8%A1%8C%E7%9A%84%20211e2dbb68cf4e7b99d61dfe95d8a6d1/Untitled%203.png)

        - 然后显示的执行缓存语句
            - `select SQL_CACHE * from user;`
        - MySQL在8.0版本删除了查询缓存的功能
    - 分析器
        - 如果没有命中查询缓存，就要准备执行语句了。在执行前，MySQL会`对SQL语句做解析`。
        - 包括词法分析和语法分析
    - 优化器
        - 优化器是在表里有`多个索引`的时候，`决定使用哪个索引`；
        - 
    - 执行器
        - 开始执行的时候，会首先判断有没有执行的权限，如果没有就直接返回错误
            - 即使命中查询缓存，在返回结果的时候也会验证权限
        - 如果有权限，就继续执行。执行器会根据表的引擎定义，来使用该引擎的接口
        - 
- 更新的SQL是怎么执行的
    - 除了执行过程概述提到的，更新流程还涉及了
        - redo log
        - binlog