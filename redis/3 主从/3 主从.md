# 3 主从

- 用法

    对于我们应该选择RDB还是AOF，官方的建议是两个同时使用。这样可以提供更可靠的持久化方案。

    像MYSQL 一样，redis是支持主从同步的，而且也支持一主多以及多级从结构。

    主从结构，一是为了纯粹的冗余备份，而是为了提升读性能，比如很消耗性能的SORT就可以由从服务器来承担。

    redis 的主从同步是异步进行的，这意味着主从同步不会影响主逻辑，也不会降低redis的处理性能。

    主从架构中，可以考虑关闭主服务器的数据持久化功能，只让从服务器进行从持久化，这样可以提高主服务器的处理性能。

    在主从架构中，从服务器通常被设置为只读模式，这样可以避免从服务器的数据被修改，但是从服务器仍然可以接收CONFIG等指令，所以还是不应该将服务器直接暴露到不安全的外网中。如果必须如此，那么可以考虑给重要指令进行重命名，来避免被外人误执行 。

- 同步原理

    从从服务器会想主服务器发出SYNC指令，当主服务接到此命令后，就会调用BGSAVE指令来创建一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入RDB中，在数据持久化期间，主服务器将执行的写指令都缓存在内存中。

    在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器接到此文件后会将其存储到磁盘上，然后再将其读到内存中。这个动作完成后，主服务器会将这个时间缓存的写指令再以redis协议的格式发送给从服务器。

    另外，即使有多个从服务器同时发来SYNC指令，主服务器也只会执行一次BGSAVE，然后把持久化好的RDB文件发给多个下游。在redis2.8之后，redis支持了增量同步策略，这大大降低了连接断开的成本。

    主服务器会在内存中维护一个缓冲区，缓冲区中存储着将要发给服务器的内容。从服务器与主服务器出现网络瞬断之后，从服务器会尝试再次与主服务器连接，一旦连接成功，从服务器就会把希望同步的主服务器ID和希望请求的数据的偏移位置发送出去，主服务器接收到这样的同步请求后，首先会验证主服务器ID是否与自己的ID匹配，其次会检查请求的偏移位置是否存在于自己的缓冲区中，如果两者都满足的话主服务器就会向从服务器发送增量内容。

    增量同步功能，需要服务器端支持全新的PSYNC指令。这个指令，只有在redis-2.8之后才具有。

- 主从

    redis提供了主从同步功能。

    通过slaveof配置项可以控制某一个redis作为另一个redis的从服务器，通过指定IP和端口来定位到主redis的位置。一般情况下，我们会建议用户为从redis设置一个不同频率的快照持久化的周期，或者为从redis配置一个不同的服务端口等等

    ```jsx
    slaveof <masterip> <masterport>
    ```

    如果主redis设置了验证密码的话（使用requirepass来设置），则在从redis的配置中要使用masterauth来设置校验密码，否则的话，主redis会拒绝从redis的访问请求。

    ```jsx
    masterauth <master-password>
    ```

    当从redis失去了与主redis的连接，或者主从同步正在进行中时，redis该如何处理外部发来的访问请求呢？这里，从redis可以有两种选择：

    第一种选择：如果slave-serve-stale-data设置为yes（默认），则从redis仍会继续响应客户端的读写请求。

    第二种选择：如果slave-serve-stale-data设置为no，则从redis会对客户端的请求返回“SYNC with master in progress”，当然也有例外，当客户端发来INFO请求和SLAVEOF请求，从redis还是会进行处理。

    你可以控制一个从redis是否可以接受写请求。将数据直接写入从redis，一般只适用于那些生命周期非常短的数据，因为在主从同步时，这些临时数据就会被清理掉。自从redis2.6版本之后，默认从redis为只读。

    ```jsx
    slave-read-only yes
    ```

    只读的从redis并不适合直接暴露给不可信的客户端。为了尽量降低风险，可以使用rename-command指令来将一些可能有破坏力的命令重命名，避免外部直接调用。比如：

    复制代码代码如下:

    ```jsx
    rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
    ```

    从redis会周期性的向主redis发出PING包。你可以通过repl_ping_slave_period指令来控制其周期。默认是10

    ```jsx
    repl-ping-slave-period 10
    ```

    在主从同步时，可能在这些情况下会有超时发生：

    1.以从redis的角度来看，当有大规模IO传输时。

    2.以从redis的角度来看，当数据传输或PING时，主redis超时

    3.以主redis的角度来看，在回复从redis的PING时，从redis超时

    用户可以设置上述超时的时限，不过要确保这个时限比repl-ping-slave-period的值要大，否则每次主redis都会认为从redis超时。

    ```jsx
    repl-timeout 60
    ```

    我们可以控制在主从同步时是否禁用TCP_NODELAY。如果开启TCP_NODELAY，那么主redis会使用更少的TCP包和更少的带宽来向从redis传输数据。但是这可能会增加一些同步的延迟，大概会达到40毫秒左右。如果你关闭了TCP_NODELAY，那么数据同步的延迟时间会降低，但是会消耗更多的带宽。（如果你不了解TCP_NODELAY，可以到这里来科普一下）。

    复制代码代码如下:

    ```jsx
    repl-disable-tcp-nodelay no
    ```

    我们还可以设置同步队列长度。队列长度（backlog)是主redis中的一个缓冲区，在与从redis断开连接期间，主redis会用这个缓冲区来缓存应该发给从redis的数据。这样的话，当从redis重新连接上之后，就不必重新全量同步数据，只需要同步这部分增量数据即可。

    复制代码代码如下:

    ```jsx
    repl-backlog-size 1mb
    ```

    如果主redis等了一段时间之后，还是无法连接到从redis，那么缓冲队列中的数据将被清理掉。我们可以设置主redis要等待的时间长度。如果设置为0，则表示永远不清理。默认是1个小时。

    复制代码代码如下:

    ```jsx
    repl-backlog-ttl 3600
    ```

    我们可以给众多的从redis设置优先级，在主redis持续工作不正常的情况，优先级高的从redis将会升级为主redis。而编号越小，优先级越高。比如一个主redis有三个从redis，优先级编号分别为10、100、25，那么编号为10的从redis将会被首先选中升级为主redis。当优先级被设置为0时，这个从redis将永远也不会被选中。默认的优先级为100。

    复制代码代码如下:

    ```jsx
    slave-priority 100
    ```

    假如主redis发现有超过M个从redis的连接延时大于N秒，那么主redis就停止接受外来的写请求。这是因为从redis一般会每秒钟都向主redis发出PING，而主redis会记录每一个从redis最近一次发来PING的时间点，所以主redis能够了解每一个从redis的运行情况。

    复制代码代码如下:

    ```jsx
    min-slaves-to-write 3
    min-slaves-max-lag 10
    ```

    上面这个例子表示，假如有大于等于3个从redis的连接延迟大于10秒，那么主redis就不再接受外部的写请求。上述两个配置中有一个被置为0，则这个特性将被关闭。默认情况下min-slaves-to-write为0，而min-slaves-max-lag为10。